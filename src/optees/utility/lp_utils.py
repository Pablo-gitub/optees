"""
Linear Programming (LP) utilities on top of SciPy/HiGHS.

Public surface:
- solve_lp(problem: dict, method="highs")
- pre_process_lp_data(...): stub
- perform_sensitivity_analysis(...): stub

The solver is source-agnostic: adapters must supply the canonical `problem` dict.
"""

from __future__ import annotations

from typing import Any, Dict, Optional, Tuple, List
import numpy as np

try:
    from scipy.optimize import linprog
except Exception as e:  # allow import even if SciPy is missing
    linprog = None
    _scipy_import_error = e

__all__ = ["solve_lp", "pre_process_lp_data", "perform_sensitivity_analysis"]


# ---------- Public API (thin orchestrator) ----------

def solve_lp(
    problem: Dict[str, Any],
    *,
    method: str = "highs",
) -> Tuple[str, Optional[float], Dict[str, float], Dict[str, Any]]:
    """
    Solve a continuous LP using SciPy/HiGHS.

    Canonical input (adapters must conform):
      problem = {
        "sense": "min" | "max",
        "c": [...],
        "A_ub": [[...], ...], "b_ub": [...],    # optional (<=)
        "A_eq": [[...], ...], "b_eq": [...],    # optional (==)
        "bounds": [[lb, ub], ...],              # optional; None for Â±inf; default (0, None)
        "var_names": ["x0","x1",...],           # optional; autogenerated if absent
        "obj_offset": float                     # optional constant added to objective
      }
    Returns: (status, objective, x_dict, extras)
    """
    if linprog is None:
        raise RuntimeError(f"SciPy not available: {str(_scipy_import_error)}")

    lp = _normalize_problem(problem)
    args = _build_linprog_args(lp)
    res = _call_linprog(args, method=method)
    return _postprocess_result(lp, res)


# ---------- Private helpers (single responsibility) ----------

def _normalize_problem(problem: Dict[str, Any]) -> Dict[str, Any]:
    """Validate and normalize inputs; compute derived fields."""
    _validate_problem(problem)

    sense = str(problem.get("sense", "min")).lower()
    flip_obj = (sense == "max")

    c = np.asarray(problem["c"], dtype=float)
    n = int(c.shape[0])

    # Optional matrices/vectors (dense or scipy.sparse are both fine)
    A_ub = problem.get("A_ub", None)
    b_ub = problem.get("b_ub", None)
    A_eq = problem.get("A_eq", None)
    b_eq = problem.get("b_eq", None)

    # Bounds: default (0, +inf)
    bounds_in = problem.get("bounds")
    if bounds_in is None:
        bounds: List[Tuple[Optional[float], Optional[float]]] = [(0.0, None)] * n
    else:
        if len(bounds_in) != n:
            raise ValueError("len(bounds) must match len(c).")
        bounds = [
            (None if lb is None else float(lb),
             None if ub is None else float(ub))
            for (lb, ub) in bounds_in
        ]

    # Variable names
    var_names = problem.get("var_names")
    if var_names is not None:
        if len(var_names) != n:
            raise ValueError("len(var_names) must match len(c).")
        var_names = list(map(str, var_names))
    else:
        var_names = [f"x{i}" for i in range(n)]

    obj_offset = float(problem.get("obj_offset", 0.0))

    return {
        "c": c,
        "A_ub": A_ub, "b_ub": b_ub,
        "A_eq": A_eq, "b_eq": b_eq,
        "bounds": bounds,
        "var_names": var_names,
        "flip_obj": flip_obj,
        "obj_offset": obj_offset,
    }


def _validate_problem(problem: Dict[str, Any]) -> None:
    """Light, source-agnostic validation."""
    if "c" not in problem:
        raise ValueError("Missing 'c' in problem.")
    sense = str(problem.get("sense", "min")).lower()
    if sense not in ("min", "max"):
        raise ValueError("problem['sense'] must be 'min' or 'max'.")

    def _pair(A, b, tag: str):
        if (A is None) ^ (b is None):
            raise ValueError(f"{tag}: A and b must be both provided or both omitted.")

    _pair(problem.get("A_ub"), problem.get("b_ub"), "A_ub/b_ub")
    _pair(problem.get("A_eq"), problem.get("b_eq"), "A_eq/b_eq")


def _build_linprog_args(lp: Dict[str, Any]) -> Dict[str, Any]:
    """Prepare arguments for scipy.optimize.linprog."""
    c_eff = -lp["c"] if lp["flip_obj"] else lp["c"]
    return {
        "c": c_eff,
        "A_ub": lp["A_ub"],
        "b_ub": lp["b_ub"],
        "A_eq": lp["A_eq"],
        "b_eq": lp["b_eq"],
        "bounds": lp["bounds"],
    }


def _call_linprog(args: Dict[str, Any], *, method: str):
    """Call SciPy linprog, catching setup/runtime exceptions."""
    try:
        return linprog(
            args["c"],
            A_ub=args["A_ub"], b_ub=args["b_ub"],
            A_eq=args["A_eq"], b_eq=args["b_eq"],
            bounds=args["bounds"],
            method=method,
        )
    except Exception as e:
        # Build a minimal object carrying the error
        class _Fail:
            status = None
            success = False
            message = str(e)
            nit = None
            crossover_nit = None
        return _Fail()


def _postprocess_result(lp: Dict[str, Any], res) -> Tuple[str, Optional[float], Dict[str, float], Dict[str, Any]]:
    """Map SciPy result to (status, objective, x_dict, extras)."""
    status = _map_status(res)

    if status == "Optimal" and getattr(res, "x", None) is not None:
        obj = float(res.fun)
        if lp["flip_obj"]:
            obj = -obj
        obj += lp["obj_offset"]
        x_dict = {name: float(val) for name, val in zip(lp["var_names"], res.x.tolist())}
    else:
        obj = None
        x_dict = {}

    extras: Dict[str, Any] = {
        "message": getattr(res, "message", None),
        "nit": getattr(res, "nit", None),
        "crossover_nit": getattr(res, "crossover_nit", None),
        "status_code": getattr(res, "status", None),
        "success": getattr(res, "success", None),
    }
    _attach_highs_marginals(res, extras)
    return status, obj, x_dict, extras


def _map_status(res) -> str:
    """Unify SciPy status codes."""
    code = getattr(res, "status", None)
    success = getattr(res, "success", False)
    if code == 0 and success:
        return "Optimal"
    if code == 2:
        return "Infeasible"
    if code == 3:
        return "Unbounded"
    return "NotSolved"


def _attach_highs_marginals(res, extras: Dict[str, Any]) -> None:
    """Attach HiGHS marginals/residuals if present (SciPy exposes them in recent versions)."""
    def _grab(name: str):
        v = getattr(res, name, None)
        if v is None:
            return None
        return {
            "marginals": getattr(v, "marginals", None),
            "residual": getattr(v, "residual", None),
        }
    for key in ("eqlin", "ineqlin", "lower", "upper"):
        g = _grab(key)
        if g is not None:
            extras[key] = g


# ---------- Stubs (to be implemented later) ----------

def pre_process_lp_data(
    problem: Dict[str, Any],
    *,
    normalize: bool = True,
    scale: bool = False,
) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    """[Stub] Lightweight pre-processing hook (normalize bounds, drop all-zero rows, etc.)."""
    return problem, {"rows_kept": None, "cols_kept": None, "scaling": None}


def perform_sensitivity_analysis(
    status: str,
    extras: Dict[str, Any],
) -> Dict[str, Any]:
    """[Stub] Turn HiGHS marginals into user-friendly sensitivity outputs."""
    return {}
